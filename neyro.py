# нейросеть в 2 слоя
import numpy as np
# X — матрица входного набор данных; строки – тренировочные примеры
# y – матрица выходного набора данных; строки – тренировочные примеры
# l0 – первый слой сети, определённый входными данными
# l1 – второй слой сети, или скрытый слой
# syn0 – первый слой весов, Synapse 0, объединяет l0 с l1.
# "*" — поэлементное умножение – два вектора одного размера умножают соответствующие значения, и на выходе получается
# вектор такого же размера
# "-" – поэлементное вычитание векторов
# x.dot(y) – если x и y – это вектора, то на выходе получится скалярное произведение. Если это матрицы, то получится
# перемножение матриц. Если матрица только одна из них – это перемножение вектора и матрицы.

# сигмоида
def nonlin(x, derif=False):
    if (derif == True):
        return x * (1 - x)
    return 1 / (1 + np.exp(-x))


# набор входных параметров
X = np.array(
        [[0, 0, 1],
         [0, 1, 1],
         [1, 0, 1],
         [1, 1, 1]])
# выходные данные
y = np.array([[0, 0, 1, 1]]).T

# сделаем случайные числа более определенные
np.random.seed(1)

# инициализируем веса случайным образом
syn0 = 2 * np.random.random((3, 1)) - 1

for iter in range(10000):
    # прямое распределение
    L0 = X
    L1 = nonlin(np.dot(L0, syn0))
    # насколько мы ошиблись
    L1_error = y - L1
    # перемножим это с наклонной сигмоды на основе значений в L1
    L1_delta = L1_error * nonlin(L1, True)  # !!!!
    # обновим веса
    syn0 += np.dot(L0.T, L1_delta)  # !!!!
print("Выходные данные после тренировки:")
print(L1)
